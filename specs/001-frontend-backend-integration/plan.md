# Implementation Plan: Frontend–Backend Integration for Streaming RAG Chatbot

**Branch**: `001-frontend-backend-integration` | **Date**: 2025-12-17 | **Spec**: [spec.md](./spec.md)

## Summary

Connect existing chatbot UI to local and deployed FastAPI backends with streaming support. Enable runtime environment switching via configuration, handle Server-Sent Events (SSE) streaming, and provide consistent error handling across both environments.

## Technical Context

**Language/Version**: JavaScript/TypeScript (ES6+), React 18
**Primary Dependencies**: Docusaurus 3.x, fetch API, EventSource (SSE)
**Storage**: N/A (frontend-only integration)
**Testing**: Manual validation against local/deployed backends
**Target Platform**: Web browser (Docusaurus embedded component)
**Project Type**: Web (frontend-only changes)
**Performance Goals**: <3s response latency, streaming render within 200ms of chunk arrival
**Constraints**: No authentication, HTTP-based communication only, must work with existing Docusaurus deployment
**Scale/Scope**: Single-user chat sessions, ~10 concurrent users supported by backend

## Constitution Check

**Accuracy and Source Verification**: ✓ Pass
- No book content modification; integration layer only

**Clarity and Accessibility**: ✓ Pass
- Error messages will be user-friendly and clear

**Traceability**: ✓ Pass
- Integration connects to existing RAG backend pipeline

**Reliability and Performance**: ✓ Pass
- <3s response latency requirement met by backend; frontend adds minimal overhead
- Error handling ensures graceful degradation

**Technology Standards**: ✓ Pass
- Frontend uses standard fetch/EventSource APIs
- Backend uses FastAPI (already established)

**Security**: ✓ Pass
- No authentication required per spec
- Input sanitization handled by existing errorHandler.js

## Project Structure

### Documentation (this feature)

```text
specs/001-frontend-backend-integration/
├── plan.md              # This file
├── contracts/
│   └── streaming-api.md # API contract for backend integration
└── tasks.md             # Generated by /sp.tasks (not created yet)
```

### Source Code (repository root)

```text
src/
├── components/
│   └── ChatInterface/
│       ├── ChatContainer.jsx        # [MODIFY] Add config prop
│       ├── MessageList.jsx          # [EXISTING] No changes
│       ├── MessageBubble.jsx        # [EXISTING] No changes
│       ├── InputArea.jsx            # [EXISTING] No changes
│       ├── TypingIndicator.jsx      # [EXISTING] No changes
│       └── index.jsx                # [MODIFY] Export config utilities
├── services/
│   ├── chatService.js               # [MODIFY] Add env-based URL switching
│   ├── streamingHandler.js          # [MODIFY] Enhance SSE error handling
│   └── scrollManager.js             # [EXISTING] No changes
├── utils/
│   ├── errorHandler.js              # [MODIFY] Add backend-specific error types
│   └── messageFormatter.js          # [EXISTING] No changes
└── theme/
    └── Root.js                      # [MODIFY] Inject backend config from env

.env.example                         # [NEW] Document env variables
```

**Structure Decision**: Web application structure with frontend-only modifications. Existing chatbot components already present; plan extends services layer to support dual-backend configuration.

## Design Decisions

### 1. Backend Selection Strategy

**Decision**: Environment variable-based configuration with runtime override capability

**Options Considered**:
| Option | Pros | Cons |
|--------|------|------|
| A. Build-time environment variables | Simple, standard practice | Requires rebuild to switch backends |
| B. Runtime toggle UI | User-friendly, no rebuild | Adds UI complexity, not in spec |
| C. Environment variables + runtime API | Flexible, backward-compatible | More complex implementation |

**Selected**: **Option A** (Environment variables)

**Rationale**:
- Spec requires "zero code changes" for backend switching
- Docusaurus supports `.env` files natively
- Development uses local backend; production uses deployed backend
- Simpler than runtime toggle, sufficient for use case

**Implementation**:
```javascript
// .env.local (development)
BACKEND_URL=http://localhost:8000

// .env.production (deployment)
BACKEND_URL=https://syedmuhammadanasmaududi-rag-chabot.hf.space
```

**Tradeoffs**:
- ✓ No UI complexity
- ✓ Standard practice
- ✗ Requires rebuild to switch (acceptable per spec)

---

### 2. Streaming Protocol Handling

**Decision**: Server-Sent Events (SSE) with fetch API fallback

**Options Considered**:
| Option | Pros | Cons |
|--------|------|------|
| A. EventSource (SSE) | Native browser support, simple | One-way only, limited control |
| B. fetch with chunked responses | More control, bidirectional | Manual parsing required |
| C. WebSockets | Full-duplex, low latency | Overkill, backend must support |

**Selected**: **Option A** (EventSource/SSE)

**Rationale**:
- Spec mentions "SSE or chunked responses"
- Existing backend likely uses SSE (standard for streaming responses)
- EventSource API is simpler and browser-native
- One-way communication sufficient for chatbot responses

**Implementation**:
```javascript
const eventSource = new EventSource(streamingUrl);
eventSource.onmessage = (event) => {
  const chunk = JSON.parse(event.data);
  appendMessageChunk(chunk);
};
eventSource.onerror = (error) => {
  handleStreamingError(error);
  eventSource.close();
};
```

**Tradeoffs**:
- ✓ Simple, native API
- ✓ Automatic reconnection
- ✗ Limited error detail (handled by custom error layer)

---

### 3. Request/Response Schema Consistency

**Decision**: Standardized JSON schema with version field for future compatibility

**Schema**:
```json
// Request
{
  "query": "string (required, max 500 chars)",
  "session_id": "string (optional, UUID)",
  "timestamp": "ISO8601 (optional)"
}

// Response (SSE stream)
{
  "type": "chunk | complete | error",
  "content": "string",
  "metadata": {
    "timestamp": "ISO8601",
    "source": "local | deployed"
  }
}
```

**Validation**:
- Frontend validates query length (max 500 chars) before sending
- Backend errors return `type: "error"` with `content` as error message
- Existing `errorHandler.js` sanitizes and validates input

**Rationale**:
- Consistent schema across both backends ensures reliable parsing
- Version field allows future backward-compatible changes
- Error type in stream allows inline error handling without closing connection

---

### 4. Timeout and Interruption Handling

**Decision**: 30-second timeout with graceful degradation and user notification

**Timeout Strategy**:
```javascript
const STREAM_TIMEOUT_MS = 30000;
let timeoutId;

eventSource.onopen = () => {
  timeoutId = setTimeout(() => {
    eventSource.close();
    showError("Response timeout - please try again");
  }, STREAM_TIMEOUT_MS);
};

eventSource.onmessage = (event) => {
  clearTimeout(timeoutId); // Reset on each chunk
  timeoutId = setTimeout(() => {
    eventSource.close();
    showError("Stream interrupted");
  }, STREAM_TIMEOUT_MS);
};
```

**Interruption Handling**:
- User can cancel ongoing requests (close EventSource)
- Network errors trigger reconnection (max 3 retries with exponential backoff)
- Partial responses are preserved and marked as "incomplete"

**Rationale**:
- 30s aligns with typical backend timeout expectations
- Reset on each chunk allows long responses to complete
- Graceful degradation ensures user isn't left waiting indefinitely

---

## Phase Breakdown

### Phase 0: Environment Configuration Setup
**Goal**: Configure environment variables for backend URL switching

**Tasks**:
1. Create `.env.example` with documented variables
2. Update `docusaurus.config.ts` to expose env vars to client
3. Test local and production builds with different backend URLs

**Validation**: Build succeeds with both local and deployed backend URLs

---

### Phase 1: Backend Integration Layer
**Goal**: Implement configurable backend URL in chatService.js

**Tasks**:
1. Modify `chatService.js`:
   - Read `BACKEND_URL` from environment
   - Construct streaming endpoint URL
   - Add URL validation
2. Update `streamingHandler.js`:
   - Implement SSE connection with EventSource
   - Add timeout handling (30s)
   - Add retry logic (3 attempts, exponential backoff)
3. Enhance `errorHandler.js`:
   - Add backend-specific error types
   - Map HTTP status codes to user-friendly messages

**Validation**: Service layer can connect to configurable backend URL

---

### Phase 2: Streaming Response Handling
**Goal**: Handle SSE streams and render incrementally

**Tasks**:
1. Update `streamingHandler.js`:
   - Parse SSE chunks (JSON format)
   - Accumulate message content
   - Detect stream completion
2. Modify `ChatContainer.jsx`:
   - Accept streaming chunks
   - Update message incrementally
   - Show typing indicator during streaming
3. Test with both backends:
   - Local backend streaming
   - Deployed backend streaming

**Validation**: Streaming responses render word-by-word from both backends

---

### Phase 3: Error Handling and Fallback
**Goal**: Consistent error handling across environments

**Tasks**:
1. Implement error scenarios:
   - Backend unreachable (network error)
   - Backend returns error response (4xx/5xx)
   - Stream timeout (30s)
   - Malformed response (parse error)
2. Add user-friendly error messages
3. Test error paths with both backends

**Validation**: All error scenarios display clear messages without crashing UI

---

### Phase 4: Validation and Testing
**Goal**: Verify integration with both local and deployed backends

**Testing Strategy**:
```markdown
# Test Cases

## TC-001: Local Backend Connection
- Start local backend at http://localhost:8000
- Configure BACKEND_URL=http://localhost:8000
- Send query "What is ROS2?"
- **Expected**: Streaming response renders incrementally
- **Pass Criteria**: Response completes without errors

## TC-002: Deployed Backend Connection
- Configure BACKEND_URL=https://syedmuhammadanasmaududi-rag-chabot.hf.space
- Send query "Explain digital twins"
- **Expected**: Streaming response renders incrementally
- **Pass Criteria**: Response completes without errors, HTTPS works

## TC-003: Environment Switching
- Build with local backend URL
- Verify connection to local backend
- Rebuild with deployed backend URL
- Verify connection to deployed backend
- **Pass Criteria**: Both builds connect to correct backend

## TC-004: Error Handling - Backend Unreachable
- Configure invalid BACKEND_URL=http://localhost:9999
- Send query
- **Expected**: Error message "Unable to connect to backend"
- **Pass Criteria**: No crash, clear error shown

## TC-005: Error Handling - Timeout
- Mock slow backend (>30s response)
- Send query
- **Expected**: Timeout error after 30s
- **Pass Criteria**: Connection closed, timeout message shown

## TC-006: Error Handling - Malformed Response
- Mock backend returning invalid JSON
- Send query
- **Expected**: Parse error message
- **Pass Criteria**: Error caught, user notified

## TC-007: Concurrent Streaming
- Send query
- While streaming, send another query
- **Expected**: First stream cancelled, second starts
- **Pass Criteria**: No orphaned connections
```

**Validation**: All 7 test cases pass for both local and deployed backends

---

## API Contracts

See `contracts/streaming-api.md` for detailed request/response schemas and error codes.

---

## Risks and Mitigation

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Backend schema mismatch | Medium | High | Document schema in contracts/, validate responses |
| CORS errors from deployed backend | Medium | High | Backend must set CORS headers; fallback error message |
| EventSource not supported in old browsers | Low | Medium | Feature detection + fallback message |
| Network interruptions during streaming | Medium | Medium | Retry logic (3 attempts) + partial response preservation |

---

## Non-Goals

- Backend deployment automation (out of scope)
- Authentication/authorization (spec explicitly excludes)
- Multi-backend load balancing (single backend per environment)
- Response caching (not required for MVP)
- Offline support (HTTP-based only per spec)

---

## Next Steps

Run `/sp.tasks` to generate actionable task list with acceptance criteria.
